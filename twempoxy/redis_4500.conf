#使用daemon 方式运行程序，默认为非daemon方式运行
daemonize yes

#pid文件位置
pidfile "/data/nosql/redis_4504/redis.pid"

#监听端口
port 4504

#绑定ip
#bind 129.0.0.1
# client 端空闲断开连接的时间
timeout 0

#日志记录级别，默认是notice，我这边使用warning,是为了监控日志方便。
# 使用warning后，只有发生告警才会产生日志，这对于通过判断日志文件是否为空来监控报警非常方便。
loglevel warning
logfile "/data/nosql/redis_4504/redis.log"

#默认是0，也就是只用1 个db,我这边设置成16，方便多个应用使用同一个redis server。
#使用select n 命令可以确认使用的redis db ,这样不同的应用即使使用相同的key也不会有问题。
databases 16

#下面是SNAPSHOTTING持久化方式的策略。
#为了保证数据相对安全，在下面的设置中，更改越频繁，SNAPSHOTTING越频繁，
#也就是说，压力越大，反而花在持久化上的资源会越多。
#所以我选择了master-slave模式，并在master关掉了SNAPSHOTTING。

# 在900秒之内，redis至少发生1次修改则redis抓快照到磁盘
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
# 使用压缩
rdbcompression yes
rdbchecksum yes
dbfilename "dump.rdb"
dir "/data/nosql/redis_4504"

# replication 设置
slave-serve-stale-data yes
slave-read-only yes
slave-priority 100

#LIMIT 设置
##redis最大可使用的内存量，如果使用redis SNAPSHOTTING的copy-on-write的持久会写方式，会额外的使用内存，
##为了使持久会操作不会使用系统VM，使redis服务器性能下降，建议保留redis最大使用内存的一半来留给持久化使用
maxmemory 256mb
##使用LRU算法删除设置了过期时间的key,但如果程序写的时间没有写key的过期时间
##建议使用allkeys-lru，这样至少保证redis不会不可写入
maxmemory-policy allkeys-lru


##append only mode设置
appendonly no
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
lua-time-limit 5000

#slow log 设置
slowlog-log-slower-than 10000
slowlog-max-len 128

##advanced config设置，下面的设置主要是用来节省内存的
hash-max-ziplist-entries 1024
hash-max-ziplist-value 2048
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
activerehashing yes

client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60


# Generated by CONFIG REWRITE
## slave 实例只需要配置 slaveof 即可
slaveof 192.168.122.128 4501