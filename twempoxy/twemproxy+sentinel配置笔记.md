### 机器

```
192.168.122.131   twemproxy,redis,sentinel
192.168.122.128   redis(master:4500,4501,4502),sentinel
192.168.122.129   redis(slave:4500,4501,4502),sentinel
```

### 效果图

配置目录： `/data/nosql/redis_端口号``

```
├── redis_4500
│   ├── redis.conf
├── redis_4501
│   ├── redis.conf
├── redis_4502
│   ├── redis.conf
└── sentinel
    ├── sentinel.conf

```


### Redis配置

```
#使用daemon 方式运行程序，默认为非daemon方式运行
daemonize yes

#pid文件位置
pidfile "/data/nosql/redis_4504/redis.pid"

#监听端口
port 4504

#绑定ip
#bind 129.0.0.1
# client 端空闲断开连接的时间
timeout 0

#日志记录级别，默认是notice，我这边使用warning,是为了监控日志方便。
# 使用warning后，只有发生告警才会产生日志，这对于通过判断日志文件是否为空来监控报警非常方便。
loglevel warning
logfile "/data/nosql/redis_4504/redis.log"

#默认是0，也就是只用1 个db,我这边设置成16，方便多个应用使用同一个redis server。
#使用select n 命令可以确认使用的redis db ,这样不同的应用即使使用相同的key也不会有问题。
databases 16

#下面是SNAPSHOTTING持久化方式的策略。
#为了保证数据相对安全，在下面的设置中，更改越频繁，SNAPSHOTTING越频繁，
#也就是说，压力越大，反而花在持久化上的资源会越多。
#所以我选择了master-slave模式，并在master关掉了SNAPSHOTTING。

# 在900秒之内，redis至少发生1次修改则redis抓快照到磁盘
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
# 使用压缩
rdbcompression yes
rdbchecksum yes
dbfilename "dump.rdb"
dir "/data/nosql/redis_4504"

# replication 设置
slave-serve-stale-data yes
slave-read-only yes
slave-priority 100

#LIMIT 设置
##redis最大可使用的内存量，如果使用redis SNAPSHOTTING的copy-on-write的持久会写方式，会额外的使用内存，
##为了使持久会操作不会使用系统VM，使redis服务器性能下降，建议保留redis最大使用内存的一半来留给持久化使用
maxmemory 256mb
##使用LRU算法删除设置了过期时间的key,但如果程序写的时间没有写key的过期时间
##建议使用allkeys-lru，这样至少保证redis不会不可写入
maxmemory-policy allkeys-lru


##append only mode设置
appendonly no
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
lua-time-limit 5000

#slow log 设置
slowlog-log-slower-than 10000
slowlog-max-len 128

##advanced config设置，下面的设置主要是用来节省内存的
hash-max-ziplist-entries 1024
hash-max-ziplist-value 2048
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
activerehashing yes

client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60


# Generated by CONFIG REWRITE
## slave 实例只需要配置 slaveof 即可
slaveof 192.168.122.128 4501
```


### sentinel 配置

* 注意事项
    * 每台机器的sentinel配置保存一致，并且只需要配置master的机器信息

```ini
# Global
##监听端口
port 26379
##使用daemon方式运行程序，默认为非daemon方式运行
daemonize yes
dir "/data/nosql/sentinel"
pidfile "/data/nosql/sentinel/sentinel.pid"
loglevel notice
logfile "/data/nosql/sentinel/sentinel.log"

## sentinel monitor <master-group-name> <ip> <port> <quorum>
####行尾的<quorum>是数字
####这个数字表明需要最少多少个sentinel互相沟通来确认某个master是否真的死了

## sentinel <option_name> <master-group-name> <option_value>
#### down-after-milliseconds :
sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了(subjectively down, 也简称为SDOWN)。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。
#### failover-timeout : 这个选项确定自动转移故障超时时间，单位毫秒
#### parallel-syncs : 在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步

#主库4500
sentinel monitor redis_14555_g1_4500 192.168.122.128 4500 2
sentinel down-after-milliseconds redis_14555_g1_4500 2500
sentinel failover-timeout redis_14555_g1_4500 10000
sentinel parallel-syncs redis_14555_g1_4500 1

#主库4501
sentinel monitor  redis_14555_g2_4501 192.168.122.128 4501 2
sentinel down-after-milliseconds redis_14555_g2_4501 2500
sentinel failover-timeout redis_14555_g2_4501 10000
sentinel parallel-syncs redis_14555_g2_4501 1

#主库4502
sentinel monitor redis_14555_g3_4502 192.168.122.128 4502 2
sentinel down-after-milliseconds redis_14555_g3_4502 2500
sentinel failover-timeout redis_14555_g3_4502 10000
sentinel parallel-syncs redis_14555_g3_4502 1
```



### twemproxy配置
```
redis_14555:
    listen: 192.168.122.130:14555
    hash: fnv1a_64
    distribution: ketama
    auto_eject_hosts: true
    redis: true
    server_retry_timeout: 2000
    server_failure_limit: 1
    servers:
    - 192.168.122.128:4500:1
    - 192.168.122.128:4501:1
    - 192.168.122.128:4502:1
```


### 启动twemproxy
```bash
/usr/local/twemproxy/sbin/nutcracker -c /usr/local/twemproxy/conf/redis_14555.yml -p /usr/local/twemproxy/conf/redis_14555.pid -o /usr/local/twemproxy/logs/redis_14555.log -v 11 -d

#查看进程
ps -ef |grep nutcracker
```


### 动态配置

sentinel 配置 client-reconfig-script 脚本

```bash
#!/bin/sh 
###  sentinel 触发执行此脚本时，会默认传递几个参数过来
###  <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>
#
monitor_name="$1"   ##monitor master-group-name
master_old_ip="$4"
master_old_port="$5"
master_new_ip="$6"
master_new_port="$7"
twemproxy_name=$(echo $monitor_name |awk -F'_' '{print $1"_"$2}')   ##注意 
## 本文前面已经提了2次让大家记住一个地方 master-group-name ，我这边的命名规则 redis_14555_g1_4500 , 这里我就是为了获取redis_14555 , 因为twemproxy 的配置文件名用的是 redis_14555.yml ；
## 这里通过获取  master-group-name 来修改 twemproxy 的配置文件，这里定的一点规范而已
 
twemproxy_bin="/usr/local/twemproxy/sbin/nutcracker"
twemproxy_conf="/usr/local/twemproxy/conf/${twemproxy_name}.yml"
twemproxy_pid="/usr/local/twemproxy/conf/${twemproxy_name}.pid"
twemproxy_log="/usr/local/twemproxy/logs/${twemproxy_name}.log"
twemproxy_cmd="${twemproxy_bin} -c ${twemproxy_conf} -p ${twemproxy_pid} -o ${twemproxy_log} -v 11 -d"
 
## 将新的master 端口和ip 替换掉 twemproxy 配置文件中旧的master 信息
sed -i "s/${master_old_ip}:${master_old_port}/${master_new_ip}:${master_new_port}/" ${twemproxy_conf}
 
## kill 掉根据redis_14555.yml配置启动的nutcracker 进程 ，并重新启动
ps -ef |grep "${twemproxy_cmd}" |grep -v grep |awk '{print $2}'|xargs kill
${twemproxy_cmd}
 
sleep 1
ps -ef |grep "${twemproxy_cmd}" |grep -v grep 
```


动态修改192.168.122.131:26379 sentinel 的配置，添加 client-reconfig-script 项

```bash
redis-cli -h 192.168.122.131 -p 26379 sentinel set redis_14555_g1_4500 client-reconfig-script /data/nosql/sentinel/client-reconfig.sh

redis-cli -h 192.168.122.131 -p 26379 sentinel set redis_14555_g2_4501 client-reconfig-script /data/nosql/sentinel/client-reconfig.sh

redis-cli -h 192.168.122.131 -p 26379 sentinel set redis_14555_g2_4502 client-reconfig-script /data/nosql/sentinel/client-reconfig.sh
```
